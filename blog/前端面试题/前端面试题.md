## vue的双向数据绑定

1、双向绑定实现了什么功能

实现了视图(view)和数据(data)的互相改变，即可通过改变数据改变视图，也可以通过视图的页面改变实现数据的改变

2、双向绑定是那两个方向

视图到数据的绑定，数据到视图的绑定

3、视图到数据的绑定是怎么实现的

视图到数据的绑定是通过事件的监听，类似于input标签可以监听input事件，通过v-modle指令对应的函数监听数据的变化，v-modle相当于@input和value

4、数据到视图的绑定是怎么实现的

要知道数据的变化可以通过Object.defineProperty()对属性设置一个set函数，当数据发生改变了就会来触发这个函数，我们只需要将一些需要更新的方法放在这里面就可以实现data更新view了

## v-show和v-if

控制手段不同：v-show是控制css的display是否为none来隐藏或展示，dom元素一直都是在的。而v-if显示隐藏是直接将整个dom元素添加或删除。
编译过程不同：v-show只是简单地基于css切换。而v-if的切换有一个局部编译/卸载的过程，切换过程中会销毁和重建内部的事件监听和子组件。
编译条件不同：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件被销毁和重建，只有渲染条件为真时才渲染。
v-show由false变为true的时候不会触发组件的生命周期。
v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false时触发组件的beforeDestory、destoryed方法。
v-if有更高的切换消耗，v-show有更高的初始渲染消耗。

## 重排(reflow)和重绘(repaint)

页面生成的过程：

1.HTML 被 HTML 解析器解析成 DOM 树；

2.CSS  被 CSS 解析器解析成 CSSOM 树；

3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Rende Tree)，这一过程称为 Attachment；

4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；

5.将布局绘制(paint)在屏幕上，显示出整个页面。第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。

渲染：

在页面的生命周期中，网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。

重绘：某些元素的外观被改变，例如：元素的填充颜色
重排：重新生成布局，重新排列元素。

重绘不一定导致重排，但重排一定会导致重绘。

下面情况会发生重排：

页面初始渲染，这是开销最大的一次重排

添加/删除可见的DOM元素

改变元素位置

改变元素尺寸，比如边距、填充、边框、宽度和高度等

改变元素内容，比如文字数量，图片大小等

改变元素字体大小

改变浏览器窗口尺寸，比如resize事件发生时

激活CSS伪类（例如：:hover）

设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow
查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。

